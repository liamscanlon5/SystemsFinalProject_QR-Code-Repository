# QR Code Generator Service

## 1) Executive Summary
**Problem:** In field operations, users often need to quickly share complex URLs or text data between devices without access to physical cables or complex syncing infrastructure. Manual data entry is error-prone and slow, and proprietary sharing tools frequently fail when moving data between different operating systems (for example, from a laptop to an Android phone).

**Solution:** This project provides a lightweight, universal tool that instantly converts any text or web link into a standard QR code image. Running as a self-contained service, it allows users to generate shareable codes on demand without relying on potentially unsafe third-party websites or installing heavy applications. The resulting QR codes can be scanned immediately by any smartphone camera, ensuring seamless data transfer between devices regardless of the hardware involved.


## 2) System Overview
**Course Concept(s):** **Flask API**. This project implements a **Flask API** to process data pipelines. It receives JSON payloads and returns image data using standard HTTP methods. I mostly utilized Case 4-5 concepts to complete this project.

**Architecture Diagram:**
This diagram shows the flow of data: a user sends a request, it enters the secure Docker container, and the Python app inside generates the image.
![Architecture Diagram](assets/architecture.png)

**Data/Models/Services:**
* **Input Data:** JSON Text Payloads (User provided).
* **Service/Library:** `qrcode` Python Library (Version 7.x).
* **Output:** PNG Image (Binary).
* **Licenses:** This project is MIT Licensed. The `qrcode` library is BSD-3-Clause Licensed.


## 3) How to Run (Local)
**Docker:**
```bash
./run.sh
```

## 4) Design Decisions
**Why this concept:** I chose a Flask API because it keeps the "heavy lifting" (making the image) separate from the user interface. This makes the system cleaner and easier to maintain. By using a container, I ensured this tool runs exactly the same on any computer—whether it's my laptop, a cloud server, or a field device—which aligns with the course's focus on building reliable systems.
*Alternatives Considered:* I considered building a simple command-line (CLI) script instead of a web server. I didn't choose this option because while a CLI is simpler, it can only be used by the person sitting at that specific computer. An API architecture was chosen because it allows the tool to be accessed remotely by mobile phones or other applications, which is much more useful in a real-world "Systems" context.

**Tradeoffs:** *Memory vs Disk:* I chose to process images in-memory (io.BytesIO) to keep the container stateless and fast, rather than saving files to disk. 
**Security/Privacy:** *Stateless:* No user data is logged or saved to a database, ensuring privacy by design.
**Ops:** *Health Check*:* A **/health** endpoint is included for container orchestration.


## 5) Results and Evaluation
**Sample Output:** Below is a QR code generated by the service:
![Generated QR Code](assets/result_screenshot.png)



Acknowledgements/Credits
